name: CI/CD Pipeline

on:
  push:
    branches:
      - dev
      - master
  pull_request:
    branches:
      - dev
      - master

jobs:
  # ============================================
  # BUILD & TEST
  # ============================================
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate

      - name: Lint code
        run: npm run lint || echo "No lint script found, skipping..."

      - name: Run tests
        run: npm test || echo "No tests found, skipping..."

      - name: Build application
        run: npm run build

  # ============================================
  # DEPLOY TO DEV/STAGING
  # ============================================
  deploy-dev:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/dev' && github.event_name == 'push'

    steps:
      - name: Deploy to dev environment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: deployer
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 10m
          script: |
            set -e
            cd ~/ai_models_tgbot

            # Pull latest dev code (preserve .env files)
            git fetch origin

            # Move .env files completely out of repo to prevent any conflicts
            mkdir -p /tmp/env_backup
            for f in .env*; do [ -f "$f" ] && mv "$f" "/tmp/env_backup/" 2>/dev/null || true; done

            # Reset and pull
            git reset --hard origin/dev

            # Restore .env files
            for f in /tmp/env_backup/.env*; do [ -f "$f" ] && cp "$f" . 2>/dev/null || true; done
            rm -rf /tmp/env_backup

            # Build dev webapp frontend
            echo "Building dev webapp..."
            docker run --rm \
              -v "$(pwd)/webapp:/app" \
              -w /app \
              node:20-alpine \
              sh -c "npm ci --include=dev && npm run build:staging"

            # Sync built files into webapp-dev-dist
            mkdir -p webapp-dev-dist
            rsync -a --delete --no-owner --no-group webapp/dist/ webapp-dev-dist/
            chmod -R 755 webapp-dev-dist
            echo "Dev webapp built successfully"

            # Seed new price items into database (upsert, safe to re-run)
            docker compose -f docker-compose.prod.yml exec -T postgres psql -U aibot -d aibot_production -c "
              INSERT INTO price_items (id, item_code, category, name, description, credits_per_unit, unit_type, metadata, is_active, created_at, updated_at)
              VALUES
                ('clnbp_' || substr(md5(random()::text), 1, 20), 'IMAGE_NANO_BANANA_PRO', 'IMAGE', 'Nano Banana Pro', 'Google Gemini 3 Pro Image (~\$0.04)', 20, '1_image', '{\"provider\":\"aimlapi\",\"model\":\"nano-banana-pro\"}', true, now(), now()),
                ('clmjy_' || substr(md5(random()::text), 1, 20), 'IMAGE_MIDJOURNEY', 'IMAGE', 'Midjourney', 'Midjourney artistic image generation (~\$0.04)', 25, '1_image', '{\"provider\":\"kieai\",\"model\":\"midjourney\"}', true, now(), now())
              ON CONFLICT (item_code) DO UPDATE SET
                name = EXCLUDED.name,
                description = EXCLUDED.description,
                credits_per_unit = EXCLUDED.credits_per_unit,
                metadata = EXCLUDED.metadata,
                updated_at = now();
            " || echo "Price item seeding failed (non-fatal)"

            # Rebuild dev-bot container (no cache to ensure fresh code)
            docker compose -f docker-compose.prod.yml build --no-cache dev-bot

            # Run database migrations
            docker compose -f docker-compose.prod.yml run --rm dev-bot npx prisma migrate deploy || echo "Migration failed (non-fatal)"

            # Restart only dev services
            docker compose -f docker-compose.prod.yml up -d dev-bot
            docker compose -f docker-compose.prod.yml restart nginx

            # Wait for health check
            sleep 30
            if ! curl -sf http://localhost:3003/health > /dev/null; then
              echo "Dev health check failed!"
              exit 1
            fi

            echo "Dev deployment successful"

      - name: Notify dev deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.ADMIN_CHAT_ID }}" \
              -d "text=üß™ Dev deployed successfully!%0ACommit: ${{ github.sha }}%0ABranch: dev"
          else
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.ADMIN_CHAT_ID }}" \
              -d "text=‚ùå Dev deployment failed!%0ACommit: ${{ github.sha }}"
          fi

  # ============================================
  # DEPLOY TO PRODUCTION
  # ============================================
  deploy-production:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'

    steps:
      - name: Deploy to production server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: deployer
          key: ${{ secrets.SERVER_SSH_KEY }}
          command_timeout: 10m
          script: |
            set -e
            cd ~/ai_models_tgbot

            # Save current commit for rollback
            PREV_COMMIT=$(git rev-parse HEAD)

            # Pull latest code (preserve .env files, discard build artifacts)
            git fetch origin

            # Move .env files completely out of repo to prevent any conflicts
            mkdir -p /tmp/env_backup
            for f in .env*; do [ -f "$f" ] && mv "$f" "/tmp/env_backup/" 2>/dev/null || true; done

            # Reset and pull
            git reset --hard origin/master

            # Restore .env files
            for f in /tmp/env_backup/.env*; do [ -f "$f" ] && cp "$f" . 2>/dev/null || true; done
            rm -rf /tmp/env_backup

            # Build webapp frontend using Docker (no Node.js needed on server)
            echo "Building webapp..."
            docker run --rm \
              -v "$(pwd)/webapp:/app" \
              -w /app \
              node:20-alpine \
              sh -c "npm ci --include=dev && npm run build:prod"
            # Sync built files into webapp-dist (preserve directory inode for nginx bind mount)
            mkdir -p webapp-dist
            rsync -a --delete --no-owner --no-group webapp/dist/ webapp-dist/
            chmod -R 755 webapp-dist
            echo "Webapp built successfully"

            # Build images on server (no cache to ensure fresh code)
            docker compose -f docker-compose.prod.yml build --no-cache

            # Run database migrations
            docker compose -f docker-compose.prod.yml run --rm bot1 npx prisma migrate deploy

            # Restart services
            docker compose -f docker-compose.prod.yml up -d

            # Restart nginx to re-mount the new webapp-dist directory
            docker compose -f docker-compose.prod.yml restart nginx

            # Wait for health check
            sleep 30
            if ! curl -sf http://localhost:3001/health > /dev/null; then
              echo "Health check failed, rolling back to $PREV_COMMIT"
              git checkout $PREV_COMMIT
              docker compose -f docker-compose.prod.yml build
              docker compose -f docker-compose.prod.yml up -d
              exit 1
            fi

            # Cleanup old images
            docker image prune -f
            echo "Deployment successful"

      - name: Notify deployment
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.ADMIN_CHAT_ID }}" \
              -d "text=üöÄ Production deployed successfully!%0ACommit: ${{ github.sha }}"
          else
            curl -s -X POST "https://api.telegram.org/bot${{ secrets.TELEGRAM_BOT_TOKEN }}/sendMessage" \
              -d "chat_id=${{ secrets.ADMIN_CHAT_ID }}" \
              -d "text=‚ùå Production deployment failed!%0ACommit: ${{ github.sha }}"
          fi
